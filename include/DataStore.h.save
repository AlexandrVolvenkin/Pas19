//-----------------------------------------------------------------------------------------------------
//  Source      : FileName.cpp
//  Created     : 01.06.2022
//  Author      : Alexandr Volvenkin
//  email       : aav-36@mail.ru
//  GitHub      : https://github.com/AlexandrVolvenkin
//-----------------------------------------------------------------------------------------------------
#ifndef CDATASTORE_H
#define CDATASTORE_H

#include <stdint.h>
#include <iostream>
#include <fstream>

#include "DataTypes.h"
#include "Dfa.h"
#include "Timer.h"
#include "StorageDevice.h"

using namespace std;
ServiceSectionAndBlocksCheck
//-----------------------------------------------------------------------------------------------------
class CDataStore : public CDfa
{
public:
    CDataStore();
    CDataStore(CStorageDevice* pxStorageDevice);
    virtual ~CDataStore();
    void CreateServiceSection(void);
    uint8_t WriteTemporaryServiceSection(void);
    uint8_t WriteServiceSection(void);
    uint8_t ReadTemporaryServiceSection(void);
    uint8_t ReadServiceSection(void);
    uint8_t CheckTemporaryBlock(void);
    uint8_t CheckBlock(void);
    uint16_t ReadBlock(uint8_t * , uint8_t );
//    bool WriteBlock(uint8_t *puiSource, uint16_t uiLength, uint8_t uiBlock);
    uint8_t WriteTemporaryBlock(void);
    uint8_t WriteBlock(void);
    uint8_t WriteBlock(uint8_t *puiSource, uint16_t uiLength, uint8_t uiBlock);
    uint8_t TemporaryServiceSectionAndBlocksCheck(void);
    uint8_t Check(void);
    bool CompareCurrentWithStoredCrc(void);
    void CrcOfBlocksCrcCreate(void);
    bool CrcOfBlocksCrcCheck(void);
    void Fsm(void);

    uint8_t GetBlockLength(uint8_t uiBlock)
    {
        return m_xServiseSection.xServiseSectionData.
               axBlockPositionData[uiBlock].uiLength;
    };

    CTimer* GetTimerPointer(void)
    {
        return &m_xTimer;
    };

    enum
    {
        CRC_LENGTH = 2,
        TAIL_LENGTH = 2,
        SERVICE_SECTION_DATA_BLOCK_NUMBER = 1,
        MAX_BLOCK_LENGTH = 256,
        MAX_ENCODED_BLOCK_LENGTH =
            ((MAX_BLOCK_LENGTH + TAIL_LENGTH) + ((MAX_BLOCK_LENGTH + TAIL_LENGTH) / 2)),
        MAX_BLOCKS_NUMBER = 10,//(TDataBase::BLOCKS_QUANTITY + SERVICE_SECTION_DATA_BLOCK_NUMBER),
        INTERMEDIATE_BUFFER_LENGTH = 512,
    };

    enum
    {
        SERVICE_SECTION_DATA = 0,
        READY_TO_WRITE_WAITING_TIMEOUT = 200,
        WRITE_END_WAITING_TIMEOUT = 10000,
    };

    enum
    {
        IDDLE = 0,

        START_WRITE_BLOCK_DATA,
        READY_TO_WRITE_WAITING_BLOCK_DATA,
        WRITE_END_WAITING_BLOCK_DATA,

        START_WRITE_TEMPORARY_BLOCK_DATA,
        READY_TO_WRITE_WAITING_TEMPORARY_BLOCK_DATA,
        WRITE_END_WAITING_TEMPORARY_BLOCK_DATA,

        START_WRITE_TEMPORARY_SERVICE_SECTION_DATA,
        READY_TO_WRITE_WAITING_TEMPORARY_SERVICE_SECTION_DATA,
        WRITE_END_WAITING_TEMPORARY_SERVICE_SECTION_DATA,

        START_WRITE_SERVICE_SECTION_DATA,
        READY_TO_WRITE_WAITING_SERVICE_SECTION_DATA,
        WRITE_END_WAITING_SERVICE_SECTION_DATA,
    };

    enum
    {
        NO_EVENT_FSM_EVENT = 0,
        WRITE_IN_PROGRESS_FSM_EVENT,
        STORAGE_DEVICE_BUSY_FSM_EVENT,
        WRITE_OK_FSM_EVENT,
        WRITE_ERROR_FSM_EVENT,
    };

    struct TBlockPositionData
    {
        uint16_t uiOffset;
        uint16_t uiLength;
        uint16_t uiEncodedLength;
        uint16_t uiCrc;
    };

    struct TServiseSectionData
    {
        uint16_t uiFreeSpaceOffset;
        uint16_t uiLength;
        uint16_t uiEncodedLength;
        uint16_t uiLastWritedBlockNumber;
        uint16_t uiBlocksNumber;
        // Контрольная сумма вычисленная из массива контрольных сумм блоков, не включая служебный.
        // Сохраняется при первой и последующих записях любых блоков через программатор.
        // Ноль или её несовпадение свидетельствует о том, что база данных создана по умоланию,
        // и не подтверждена пользователем. В этом случае прибор переходит в режим сигнализации об ошибке,
        // ожидая квитирования или записи базы данных.
        uint16_t uiCrcOfBlocksCrc;
        TBlockPositionData axBlockPositionData[MAX_BLOCKS_NUMBER];
    };

    struct TServiseSection
    {
        TServiseSectionData xServiseSectionData;
        uint16_t uiCrc;
    };

    enum
    {
        // Нулевой байт может быть стёрт при сбое питания.
        TEMPORARY_BLOCK_DATA_BEGIN = 8,
        TEMPORARY_SERVICE_SECTION_DATA_BEGIN =
            (TEMPORARY_BLOCK_DATA_BEGIN + MAX_ENCODED_BLOCK_LENGTH),
        SERVICE_SECTION_DATA_BEGIN =
            TEMPORARY_SERVICE_SECTION_DATA_BEGIN +
            (sizeof(struct TServiseSection) + (sizeof(struct TServiseSection) / 2)),
    };


protected:
private:
    // Данные контекста записи блока.
    uint8_t m_uiBlock;
    uint8_t* m_puiBlockSource;
    uint16_t m_uiBlockLength;

    CStorageDevice* m_pxStorageDevice;
    // Служебные данные системы хранения.
    TServiseSection m_xServiseSection;
    // Массив контрольных сумм блоков.
    uint16_t m_auiBlocksCurrentCrc[MAX_BLOCKS_NUMBER];
    uint8_t* m_puiIntermediateBuff;
    CTimer m_xTimer;
};

//-----------------------------------------------------------------------------------------------------
#endif // CDATASTORE_H
